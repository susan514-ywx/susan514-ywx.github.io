{"meta":{"title":"Susan","subtitle":"","description":"","author":"Susan","url":"https://susan514-ywx.github.io","root":"/"},"pages":[{"title":"tag","date":"2020-02-04T11:24:34.000Z","updated":"2020-02-04T11:33:39.480Z","comments":true,"path":"tags/index.html","permalink":"https://susan514-ywx.github.io/tags/index.html","excerpt":"","text":""},{"title":"cate","date":"2020-02-04T11:11:38.000Z","updated":"2020-02-04T11:39:24.765Z","comments":true,"path":"categories/index.html","permalink":"https://susan514-ywx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构笔记","slug":"数据结构笔记","date":"2020-08-07T06:33:01.745Z","updated":"2020-08-07T06:42:43.122Z","comments":true,"path":"2020/08/07/数据结构笔记/","link":"","permalink":"https://susan514-ywx.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据结构与算法分析 教材：数据结构与算法分析——C语言描述 最大子序列和问题的解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;int fun1(int a[])&#123; int i,j,k; int maxsum=0,sum; for(i=0;i&lt;4;i++)&#123; for(j=i;j&lt;4;j++)&#123; sum=0; for(k=i;k&lt;=j;k++) sum+=a[k]; if(sum&gt;maxsum) maxsum=sum; &#125; &#125; return maxsum;&#125;int fun2(int a[])&#123; int i,j,sum=0,maxsum=0; for(i=0;i&lt;4;i++)&#123; sum=0; for(j=i;j&lt;4;j++)&#123; sum+=a[j]; if(maxsum&lt;sum) maxsum=sum; &#125; &#125; return maxsum;&#125;//在线处理 int fun3(int a[])&#123; int i,sum=0,maxsum=0; for(i=0;i&lt;4;i++) &#123; sum+=a[i]; if(sum&gt;=maxsum) maxsum=sum; else if(sum&lt;0) sum=0; &#125; return maxsum;&#125;int main()&#123; int a[4]=&#123;1,2,4,5&#125;; int maxsum1=fun1(a); int maxsum2=fun2(a); int maxsum3=fun3(a); printf(\"%d %d %d\",maxsum1,maxsum2,maxsum3); &#125; tips: 数学基础：1、三定义 ​ 2、典型的增长率 函数 名称 c 常数 logN 对数级 (log N)^2 对数平方根 N 线性级 Nlog N 一般将平方级转换为此级 N^2 平方级 N^3 立方级 2^N 指数级 线性表链式存储实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct list&#123; int xishu; int zhishu; struct list *next; &#125;L;//Not use of a header node//creat listL *Creat()&#123; L *head=NULL,*p=NULL,*q=NULL; q=p=(L*)malloc(sizeof(L)); scanf(\"%d%d\",&amp;(p-&gt;xishu),&amp;(p-&gt;zhishu)); while(p-&gt;xishu!=0) &#123; if(head==NULL) head=p; else q-&gt;next=p;//q=p;错误 q=p; p=(L*)malloc(sizeof(L)); scanf(\"%d%d\",&amp;p-&gt;xishu,&amp;p-&gt;zhishu); &#125; q-&gt;next=NULL; free(p); return head; &#125; //length of the listint length(L *head)&#123; L *p; p=head; int j=0; while(p) &#123; p=p-&gt;next; j++; &#125; return j;&#125;//FindKthL* FindKth(int K,L *head)&#123; L *p=head; int i; //while(p!=NULL&amp;&amp;i&lt;K) //while(p!=NULL&amp;&amp;K--)错误 ,始终导致p指向NULL while(p!=NULL&amp;&amp;--K) &#123; p=p-&gt;next; i++; &#125; //if(i==K) if(!K) return p; else return NULL;&#125;//find the valueL* find(int x,L *head)&#123; L *p=head; while (p!=NULL&amp;&amp;p-&gt;zhishu==x) &#123; p=p-&gt;next; &#125; return p;&#125;//insertL* insert(int a,int b,int position,L*head)&#123; L*p=head; if(position==1) &#123; L *s=(L*)malloc(sizeof(L)); s-&gt;xishu=a; s-&gt;zhishu=b; return p; &#125; L* q=FindKth(position-1,head); if(q==NULL) printf(\"error\"); else &#123; L *s=(L*)malloc(sizeof(L)); s-&gt;xishu=a; s-&gt;zhishu=b; s-&gt;next=q-&gt;next; q-&gt;next=s; return p; &#125; &#125; //deletL *del(int position,L *head)&#123; L *s; if(position==1) &#123; if(head==NULL) return NULL; else&#123; s=head; head=head-&gt;next; free(s); return head; &#125; &#125; L *p; p=FindKth(position-1,head); if(p==NULL)&#123; printf(\"第%d个结点不存在\",position-1); return NULL; &#125; else if(p-&gt;next==NULL)&#123; printf(\"第%d个结点不存在\",position);return NULL; &#125;else&#123; s=p-&gt;next; p-&gt;next=s-&gt;next; free(s); return head; &#125; &#125;//print the listvoid print(L *head)&#123; L *p=head; if(p==NULL) &#123; printf(\"Empty\"); &#125; while(p) &#123; printf(\"%d %d\\n\",p-&gt;xishu,p-&gt;zhishu); p=p-&gt;next; &#125;&#125;int main()&#123; L*head; printf(\"创建链表 ,打印链表\\n\"); head=Creat();//创建链表 print(head);//打印链表 printf(\"打印链表长度\\n\"); printf(\"%d\\n\",length(head));//打印链表长度 int num=2; printf(\"按序号查找第%d个\\n\",num); L*p= FindKth(num,head);//按序号查找 if(p) printf(\"%d %d\\n\",p-&gt;xishu,p-&gt;zhishu); printf(\"按序号删除第%d个\\n\",num); head=del(num,head);//按序号删除 print(head);//打印链表 int a=0,b=0,position=num;//插入元素 printf(\"按序号插入第%d个元素%d %d\\n\",num,a,b); head=insert( a, b, position,head); print(head);//打印链表 &#125; 1.队列队列的顺序存储实现队列的链表存储实现2.二叉树以下以二叉查找树来学习对树的各种操作。 2.1二叉查找树的存储结构2.1.1顺序存储结构完全二叉树： ​ 从上到下、从左到右顺序存储n个结点的完全二叉树的结点父子关系： 非根节点的父节点的序号是i%2 结点的左孩子的序号是2i,右孩子的序号是2i+1 一般的树： 看成完全二叉树， 2.1.2动态链表存储不考虑含有重复的元素，非递归。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *TreeNode;typedef TreeNode Tree; struct TNode&#123; ElementType Data; TNode *left; TNode *right;&#125;;void insert(Tree *T,ElementType data)&#123; TreeNode node; node=(TreeNode )malloc(sizeof(struct TNode)); node-&gt;Data = data; node-&gt;left = NULL; node-&gt;right = NULL; if(*T == NULL) &#123; *T=node; return ; &#125; else&#123; TreeNode temp =*T; while(temp != NULL)&#123; if(data&lt; temp-&gt;Data)&#123; if(temp-&gt;left == NULL)&#123; temp-&gt;left =node; return ; &#125; else&#123; temp = temp-&gt;left; &#125; &#125; else&#123; if(temp-&gt;right == NULL)&#123; temp-&gt;right = node; return ; &#125; else&#123; temp = temp-&gt;right; &#125; &#125; &#125; &#125; &#125;int main()&#123; int a[7]=&#123;6,3,8,2,5,1,7&#125;; Tree T; T=NULL; int i; for(i=0;i&lt;7;i++) &#123; insert(&amp;T,a[i]);//建立二查搜索树 &#125;&#125; 2.1.3静态链表存储结构数组表示二叉树：静态链表 图解： 实现： 2.2二叉查找树的遍历2.2.1遍历类型 先序遍历：先访问根节点，再遍历左子树，再遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点 每次遍历的路径为以根节点为起点和终点的圈，先序遍历为第一次经过时打印，中序遍历为第二次经过时打印，后序遍历为第三次经过时打印。 2.2.2遍历代码实现12345678910111213141516171819202122232425262728void preorder(Tree T)&#123; if(T != NULL) &#123; printf(\"%d \",T-&gt;Data); preorder(T-&gt;left); preorder(T-&gt;right); &#125;&#125;void inorder(Tree T)&#123; if(T != NULL) &#123; inorder(T-&gt;left); printf(\"%d \",T-&gt;Data); inorder(T-&gt;right); &#125;&#125;void postorder(Tree T)&#123; if(T != NULL) &#123; postorder(T-&gt;left); postorder(T-&gt;right); printf(\"%d \",T-&gt;Data); &#125;&#125; 2.3二叉查找树的搜索123456789101112TreeNode search(Tree T,ElementType x)&#123; if(T == NULL)&#123; return NULL; &#125; if(x&lt;T-&gt;Data) search(T-&gt;left,x); else if(x&gt;T-&gt;Data) search(T-&gt;right,x); else return T;&#125; 2.4二叉查找树的最大最小值1234567891011121314151617181920212223242526TreeNode findmin(Tree T)&#123; if(T == NULL) return NULL; else if(T-&gt;left == NULL) return T; else findmin(T-&gt;left);&#125;TreeNode findmax(Tree T)&#123; /* if(T == NULL) return NULL; if(T-&gt;right == NULL) return T; else findmax(T-&gt;right); */ if(T == NULL)return NULL; while(T-&gt;right != NULL)&#123; T = T-&gt;right; &#125; return T; &#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://susan514-ywx.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"简单链表","slug":"C++与链表的混用","date":"2020-04-07T08:58:05.659Z","updated":"2020-04-10T13:28:56.298Z","comments":true,"path":"2020/04/07/C++与链表的混用/","link":"","permalink":"https://susan514-ywx.github.io/2020/04/07/C++%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%B7%E7%94%A8/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;fstream&gt;using namespace std;struct stu_node&#123; int num; float score; struct stu_node *next;&#125;;struct stu_node *creat()&#123; stu_node *p1=NULL,*p2=NULL,*head=NULL; int n; float s; //cout&lt;&lt;\"请输入学号和成绩：(遇到0结束)\"&lt;&lt;endl; //cin&gt;&gt;n&gt;&gt;s; ifstream in; ofstream out; in.open(\"lianbiao.txt\"); in&gt;&gt;n&gt;&gt;s;//in,cout对象就是文件对象，处理的是文件和内存的关系。 while(s!=0) &#123; char c; p1=(struct stu_node*)malloc(sizeof(struct stu_node)); p1-&gt;num=n; p1-&gt;score=s; if(head==NULL)head=p1; else p2-&gt;next=p1; p2=p1; in&gt;&gt;n&gt;&gt;s; &#125; p2-&gt;next=NULL; in.close(); return head;&#125;void list (struct stu_node *head)&#123; struct stu_node *p; if(head==NULL) cout&lt;&lt;\"链表为空\"&lt;&lt;endl; else &#123; cout&lt;&lt;\"链表内容为下：\"&lt;&lt;endl; p=head; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;num&lt;&lt;\" \"&lt;&lt;p-&gt;score&lt;&lt;endl; p=p-&gt;next; &#125; &#125; &#125;int main()&#123; struct stu_node *head; head=creat(); list(head); &#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://susan514-ywx.github.io/tags/C/"}]},{"title":"向数字中有序插入数组","slug":"向有序数组插入","date":"2020-03-14T03:18:37.254Z","updated":"2020-03-14T03:28:53.083Z","comments":true,"path":"2020/03/14/向有序数组插入/","link":"","permalink":"https://susan514-ywx.github.io/2020/03/14/%E5%90%91%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5/","excerpt":"","text":"向数字中有序插入数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;//const int MAX=5;bool insert(int array[],int&amp; num_else,int array_size,int new_number)&#123; int pos=0; if(num_else==array_size) return false; if(num_else==0) array[0]=new_number; else&#123; while(pos&lt;num_else&amp;&amp;new_number&gt;array[pos]) pos++;//寻找位置 for(int i=num_else;i&gt;pos;i--) array[i]=array[i-1]; array[pos]=new_number; &#125; num_else++; return true; &#125;int main()&#123; const int MAX=5; int n,len_of_array=0,array[MAX]; char more; bool success; do&#123; cout&lt;&lt;\"请输入要入的数字：\" ; cin&gt;&gt;n; success=insert( array,len_of_array,MAX,n); if(success) &#123; cout&lt;&lt;\"插入后\"&lt;&lt;n&lt;&lt;\"的数列为：\" ; for(int i=0;i&lt;len_of_array;i++) &#123; cout&lt;&lt;array[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; do&#123; cout&lt;&lt;\"是否还继续插入(y or n):\" ; cin&gt;&gt;more; &#125;while(more!='n'&amp;&amp;more!='N'&amp;&amp;more!='Y'&amp;&amp;more!='y'); &#125;else &#123; cout&lt;&lt;\"数组已满，无法插入\"&lt;&lt;endl; more='n'; &#125; &#125;while(more=='y'||more=='Y'); &#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://susan514-ywx.github.io/tags/C/"}]},{"title":"type of date","slug":"数据类型详细介绍","date":"2020-03-04T10:02:49.644Z","updated":"2020-04-10T13:28:54.988Z","comments":true,"path":"2020/03/04/数据类型详细介绍/","link":"","permalink":"https://susan514-ywx.github.io/2020/03/04/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"整数类型 类型 类型说明 字节数 数值范围 短整型 short 2 -32768~32767 基本整形 int 4 -2147483648~2147483647 长整型 long 4 -2147483648~2147483647 无符号短整型 unsigned short 2 0~65535 无符号整形 unsigned 4 0~429497295 无符号长整型 unsigned 4 0~429497295 # 数据自动转化规则 ①若参与运算量的类型不同，则先转换成同一类型，然后进行运算②转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算 a、若两种类型的字节数不同，转换成字节数高的类型 b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型③所有的浮点运算都是以双精度进行的，即使是两个float单精度量运算的表达式，也要先转换成double型，再作运算.④char型和short型参与运算时，必须先转换成int型⑤在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入","categories":[],"tags":[]},{"title":"Multiple inheritance","slug":"multiple","date":"2020-03-01T03:16:51.548Z","updated":"2020-03-04T11:08:52.795Z","comments":true,"path":"2020/03/01/multiple/","link":"","permalink":"https://susan514-ywx.github.io/2020/03/01/multiple/","excerpt":"","text":".c文件，以c为扩展名，一般存储具体功能的实现。.h文件，称为头文件，一般存储类型的定义，函数的声明等。通常，头文件被.c文件包含，使用#include 语句。但值得注意的是，这只是一种约定，而非强制。下面依次为time24.htim24.cppcalendar.hcalendar.cppmultiple_inheritance.cpp 12345678910111213#if !defined time24_C#define time24_Cclass time24&#123; public: time24(int h,int min,int s); void set_time(int h,int min,int s); void get_time(int &amp;h,int &amp;min,int &amp;s)const; private: int hours; int mins; int secs;&#125;;#endif 123456789101112131415161718#include&lt;iostream&gt;#include\"time24.h\"using namespace std;time24::time24(int h,int min,int s):hours(h),mins(min),secs(s)&#123;&#125;void time24::set_time(int h,int min,int s)&#123; hours=h; mins=min; secs=s;&#125;void time24::get_time(int &amp;h,int &amp;min,int &amp;s)const&#123; h=hours; min=mins; s=secs;&#125; 123456789101112131415#if !defined calendar_H#define calendar_Hclass calendar&#123; public: calendar(int d=1,int m=1,int y=1970); void set_date(int d,int m,int y ); void get_date(int &amp;d,int &amp;m,int &amp;y)const; protected: int day; int year; int month; &#125;;#endif 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;iomanip&gt;#include\"calendar.h\"using namespace std;//Constructorcalendar::calendar(int d,int m,int y): day(d),month(m),year(y)&#123; &#125; //mutator functionvoid calendar::set_date(int d,int m,int y)&#123; day=d; month=m; year=y;&#125;//inspector functionvoid calendar::get_date(int &amp;d,int &amp;m,int &amp;y)const&#123; d=day; m=month; y=year;&#125; 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include\"time24.h\"#include\"time24.cpp\"#include\"calendar.h\"#include\"calendar.cpp\"using namespace std;class date_time :public calendar,public time24&#123; public: date_time( int d=1,int mon=1,int y=1970,int h=0,int min=0,int s=0);&#125;;date_time::date_time(int d,int mon,int y,int h,int min,int s) :calendar(d,mon,y),time24(h,min,s)&#123; &#125; main()&#123; date_time dt(25,12,1999,0,0,0); int day,month,year,hours,mins,secs; dt.get_date(day,month,year); dt.get_time(hours,mins,secs); cout&lt;&lt;\"date and time is:\"&lt;&lt;endl; cout&lt;&lt;day&lt;&lt;\"/\"&lt;&lt;month&lt;&lt;\"/\"&lt;&lt;year&lt;&lt;endl; cout&lt;&lt;hours&lt;&lt;\":\"&lt;&lt;mins&lt;&lt;\":\"&lt;&lt;secs&lt;&lt;endl; dt.set_date(1,1,2000); dt.set_time(1,2,3); dt.get_date(day,month,year); dt.get_time(hours,mins,secs); cout&lt;&lt;\"date and time is:\"&lt;&lt;endl; cout&lt;&lt;day&lt;&lt;\"/\"&lt;&lt;month&lt;&lt;\"/\"&lt;&lt;year&lt;&lt;endl; cout&lt;&lt;hours&lt;&lt;\":\"&lt;&lt;mins&lt;&lt;\":\"&lt;&lt;secs&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://susan514-ywx.github.io/tags/C/"}]},{"title":"级数求和","slug":"级数求和","date":"2020-02-27T14:08:41.950Z","updated":"2020-02-27T14:16:12.380Z","comments":true,"path":"2020/02/27/级数求和/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/27/%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/","excerpt":"","text":"已知：Sn = 1 ＋ 1／2 ＋ 1／3 ＋ … ＋ 1／n。显然对于任意一个整数K，当n足够大的时候，Sn大于K。现给出一个整数K（1 &lt;= K &lt;= 15），要求计算出一个最小的n，使得Sn &gt; K。 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int k,n,i; double sum=0; scanf(\"%d\",&amp;k); for(i=1 ; ;i++) &#123; sum+=(double)1/i; if(sum&gt;k) &#123; n++; break; &#125; n++; &#125; printf(\"%d\",n); return 0; &#125;","categories":[],"tags":[{"name":"question types of ACM","slug":"question-types-of-ACM","permalink":"https://susan514-ywx.github.io/tags/question-types-of-ACM/"}]},{"title":"正整数A+B","slug":"正整数相加","date":"2020-02-20T14:34:34.977Z","updated":"2020-02-21T06:31:48.834Z","comments":true,"path":"2020/02/20/正整数相加/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/20/%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"正整数A+B 题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。 输入格式： 输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。 注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。 输出格式： 如果输入的确是两个正整数，则按格式A + B = 和输出。如果某个输入不合要求，则在相应位置输出?，显然此时和也是?。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/*//下面是错误思路,只对了设标志这一点 #include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; int flag1=0,flag2=0; cin&gt;&gt;a;//cin&gt;&gt;的返回值为cin(非0） if(cin)flag1=1;//该语句是正确的 cin&gt;&gt;b;//该语句中cin&gt;&gt;读取受第一次cin&gt;&gt;的影响，第一次若能正常读取，本次也可，第一次若不能正常读取 ，则本次也不能。 if(cin)flag2=1; if(flag1&amp;&amp;flag2) printf(\"%d + %d = %d\",a,b,a+b); else if(flag1) printf(\"%d + ? = ?\",a); else if(flag2) printf(\"? + %d = ?\",b); else printf(\"%d + %d = %d\"); &#125;*/ //参考了一下别人写的代码如下：//总结:主要是单个字符访问C++ strings不会用，有关吸收空格的函数不熟练 //对C++输入流对象cin的详细介绍：&lt;https://www.cnblogs.com/jainszhang/p/10654562.html&gt;//缓冲区：&lt;https://blog.csdn.net/qq_35981069/article/details/79448454 &gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int trans(string a) //判断a,b是否为题目范围内的正整数 &#123; int t=0; for(int i=0;i&lt;a.length();i++) &#123; if(a[i]&lt;'0'||a[i]&gt;'9') return 0; &#125; for(int i=0;i&lt;a.length();i++) &#123; t=t*10+a[i]-'0'; &#125; if(t&gt;1000||t&lt;=0) return 0; return 1;&#125;int number(string a)&#123; int t=0; for(int i=0;i&lt;a.length();i++) &#123; t=t*10+a[i]-'0'; &#125; return t;&#125;int main()&#123; string a,b; int flag1=1,flag2=1; int x,y; cin&gt;&gt;a; getchar(); getline(cin,b);//b中可能含有空格 flag1=trans(a); flag2=trans(b); if(flag1&amp;&amp;flag2) &#123; x=number(a); y=number(b); printf(\"%d + %d = %d\",x,y,x+y); &#125; if(flag1&amp;&amp;!flag2) &#123; x=number(a); printf(\"%d + ? = ?\",x); &#125; if(flag2&amp;&amp;!flag1)&#123; y=number(b); printf(\"? + %d = ?\",y); &#125; if(!flag1&amp;&amp;!flag2) printf(\"? + ? = ?\"); &#125;","categories":[],"tags":[{"name":"question types of ACM","slug":"question-types-of-ACM","permalink":"https://susan514-ywx.github.io/tags/question-types-of-ACM/"}]},{"title":"notes of python","slug":"python","date":"2020-02-15T11:02:29.581Z","updated":"2020-02-17T09:44:46.516Z","comments":true,"path":"2020/02/15/python/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/15/python/","excerpt":"","text":"初学python（有C的基础） 1.写出习题的代码，在 Linux 下用 gedit，OSX 下用 TextWrangler，Windows 下用 Notepad++。 2.运行你写的习题。 3.修改错误的地方。 4.重复上述步骤。 工具：Notepad++文本编译器 PowerShell 热身 使用terminal创建一个目录&gt;输入mkdir命令创建一个新目录，如mkdir new_dir 创建一个名为new_dir的新目录 使用terminal进入一个目录一直cd简单方法日后更 使用键盘切换回到Terminal窗口win+x 列出文件夹中的内容&gt;dir 语言元素变量和类型 整型：python3.x中可以处理任意大小的整数 浮点型 字符型：由单引号或双引号括起来的任意文本（原始字符串表示法，字节表示法，Unicode表示以后了解） 布尔型：Ture False(首字符大写） 复数型：高中学的复数一样，只做了解 变量命名 硬性规则：与C一样 PEP8要求： 1.用小写字母拼写，多个单词用下划线连接 2.受保护的实例属性用单个下划线开头 3.私有的实例属性用两个下划线开头变量的使用用实例看变量1234567891011#使用type()来检测变量的类型a=100b=1.23c=1+5jd='hello world'e=Trueprint(type(a))print(type(b))print(type(c))print(type(d))print(type(e)) python内置函数对变量类型进行转换 int() float() str() chr（） ord() 12345678#使用input()函数获取键盘输入（字符串）#使用print（）函数输出带占位符的字符串a=int(input('a= '))b=int(input('b= '))print('%d+%d=%d'%(a,b,a+b))print('%d//%d=%d'%(a,b,a//b))print('%d%%%d=%d'%(a,b,a%b))//注意print('%d**%d=%d'%(a,b,a**b)) 运算符 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in not or and 逻辑运算符 = += -= = /= %= //= *= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` python格式化字符串 转换说明符 描述 %d、%i 转换为带符号的十进制整数 %o 转换为带符号的八进制整数 %x、%X 转换为带符号的十六进制整数 %e 转化为科学计数法表示的浮点数（e 小写） %E 转化为科学计数法表示的浮点数（E 大写） %f、%F 转化为十进制浮点数 %g 智能选择使用 %f 或 %e 格式 %G 智能选择使用 %F 或 %E 格式 %c 格式化字符及其 ASCII 码 %r 使用 repr() 函数将表达式转换为字符串（什么字符都可输出） %s 使用 str() 函数将表达式转换为字符串 练习：判断是否为闰年 123year=int(input('请输入一个年份：'))is_leap=(year%4==0 and year%100!=0 or year%400==0)print(is_leap) 附：这也是teacher Lin向我提问的第一个问题，结果我把第1，3个%写成了//，今天又重蹈覆辙。能否被整除要用取余运算符，看余数是否为0，而不是用取整运算符，带个整字，就老想翻你的牌子，因此为诫以后涉及于此能想到这两次教训。 分支结构if语句的使用关键字：if else elif 123456username=input('请输入用户名：')password=input('请输入口令：')if username=='admin' and password =='12345': print('身份验证成功！')else: print('身份验证失败！') Python中不用花括号构造代码块用缩进的方式设置代码层次结构，缩进格式形同则为一个代码块. 更多的分支可用if…elif…else如下面分段函数求值 12345678x=float(input('x= '))if x&gt;1: y=3*x-5elif x&gt;-1: y=x+2else: y=5*x+3print('f(%.2f)=%.2f' %(x,y)) 还可以用嵌套分支结构 123456789x=float(input('x= '))if x&gt;1: y=3*x-5else: if x&gt;=-1: y = x + 2 else: y=5*x+3print('f(%.2f)=%.2f' %(x,y)) 练习： 1234567891011score=int(input('score='))if score&gt;=90: print('A')elif score&gt;=80 and score&lt;90: print('B')elif score&gt;=70 and score&lt;80: print('C')elif score&gt;=60 and score&lt;70: print('D')else: print('E') 循环结构用来重复执行某条或某些命令，有for-in和while两种循环 for-in 适合已知循环次数 12345#用for循环实现1~100求和sum = 0for x in range(101): sum +=xprint(sum) range()可构造整数的序列并能应用于循环中例如： range(101)可以产生一个0到100的整数序列。 range(1,100)可以产生一个1到99的整数序列。 range(1,100,2)可以产生1到99的奇数序列，步幅为2. 相当于前闭后开区间 while循环 适合不知道循环次数 1234567891011121314151617#猜数字游戏import random answer = random.randint(1,100)count =0while True: count +=1 number=int(input('请输入：')) if number &lt; answer: print('大一点') elif number &gt;answer: print('小一点') else: print('恭喜你猜对了！') breakprint('你一共猜了 %d 次' %count)if count &gt; 7: print('你的智商余额不足') 练习： 1234567891011x=int (input ('x='))y=int (input ('y='))if x&gt;y: #交换两个数的值 x,y=y,x#从两个数中较小的数开始做递减循环for factor in range (x,0,-1): if x%factor==0 and y%factor ==0: print('%d和%d的最小公约数为%d'%(x,y,factor)) print('%d和%d的最大公倍数为%d'%(x,y,(x*y)//factor)) break 12345678910111213141516171819202122232425262728293031323334353637#print()函数模型#print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)\"\"\" * ** *** ********* * *** ***** ****************错误思路，与C语言的不同row=int (input('input= '))for i in range (row): for j in range (row-1-i): print(' ',end='') for t in range (i): print('*',end='')print()\"\"\"row=int (input('input= '))for i in range(row): for j in range(row): if j&lt;row-1-i: print(' ',end='')//注意有无空格 else: print('*',end='') print() for i in range(row): for j in range(row-i-1): print(' ',end ='') for j in range(2*i+1): print('*',end ='') print() 制造程序逻辑 经典例题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#水仙花数for num in range (100,1000): low =num % 10 mid =num // 10%10 high=num//100 if num==low**3+mid**3 +high**3: print(num)#整数的反转num =int (input('x= '))reversed_num=0while num&gt;0: reversed_num=reversed_num*10+num%10 num//=10print(reversed_num)#百钱百鸡（穷举法，暴力搜索法）for i in range(0,20): for j in range (0,33): z=100-j-i if 5*i+3*j +z/3==100: print('公鸡：%d 只，母鸡：%d,小鸡：%d只'%(i,j,z))#CRAPS赌博游戏from random import randintmoney=1000while money&gt;0: print('你的总资产为：',money) needs_go_on=False while True : debt=int(input('请下注：')) if 0&lt;debt&lt;=money: break first=randint(1,6)+randint(1,6) print('玩家摇出了%d点'%first) if first==7 or first==11: print('玩家胜！') money+=debt elif first ==2 or first ==3 or first==12: print('庄家胜！') money-=debt else: needs_go_on =True while needs_go_on: needs_go_on=False current=randint(1,6)+randint(1,6) print('玩家摇出了%d点'%current) if current==7: print('庄家胜！') money-=debt elif current==first : print('玩家胜') money+=debt else: needs_go_on = Trueprint('你破产了，游戏结束！')","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://susan514-ywx.github.io/tags/python/"}]},{"title":"C++重载构造函数","slug":"重载构造","date":"2020-02-08T11:44:39.660Z","updated":"2020-02-08T12:31:46.509Z","comments":true,"path":"2020/02/08/重载构造/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/08/%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0/","excerpt":"","text":"给private成员变量赋初值，要通过构造函数（这也是构造函数的作用），不可以在类内直接赋值。 默认构造函数（其实在定义了对象后会自动调用计算机已经写好了的一个默认构造函数，初始值都为0，但作为基本素养，一般会亲自再写一个默认构造函数）（简单点说默认就是指没有实参，初值随意啦） 重载构造函数（此时就是按需自由给private成员变量赋值）123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class elevator&#123; public: elevator(); elevator(int floor); void change(); void display(); private: int floor;&#125;;elevator::elevator()&#123; floor=0; printf(\"调用该函数1\");&#125;elevator::elevator(int floor1)&#123; floor=floor1; //floor=0;我想调用重载构造函数，但传实参时，结果一直是0，ou~找了好久的错，终于逮住着这个bug了，我直接给变量赋0，传啥也不管用了 printf(\"调用该函数2\\n\");&#125;void elevator::change()&#123; char fuhao; cin&gt;&gt;fuhao; if(fuhao=='-'&amp;&amp;floor&gt;=1) floor--; if(fuhao=='+'&amp;&amp;floor&lt;=10) floor++; &#125;void elevator::display()&#123; cout&lt;&lt;floor;&#125;int main()&#123; elevator elevator(19); // elevator.change(); elevator.display(); return 0; &#125;","categories":[],"tags":[{"name":"base of C++","slug":"base-of-C","permalink":"https://susan514-ywx.github.io/tags/base-of-C/"}]},{"title":"桶思想","slug":"acm题型 (2)","date":"2020-02-04T11:17:37.469Z","updated":"2020-02-04T11:39:26.065Z","comments":true,"path":"2020/02/04/acm题型 (2)/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/04/acm%E9%A2%98%E5%9E%8B%20(2)/","excerpt":"","text":"#桶思想的应用 什么是桶思想有种排序为桶排序（还不了解），这种方法耗费了内存空间，但是将时间复杂程度降成了线性，它的特点是先分出一定数目的桶，然后将数字映射到各自的桶中，再对非空桶快速排列。 何时使用该思想？例如：统计一位学生的成绩，可以给试卷分一定数目的桶，学生的成绩即对应桶。 当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。输入格式：输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。输出格式：按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。注意：同一个人可以被查询多次，但只输出一次。输入样例1：33 11111 22222 555552 33333 444444 55555 66666 99999 77777855555 44444 10000 88888 22222 11111 23333 88888输出样例1：10000 88888 23333输入样例2：33 11111 22222 555552 33333 444444 55555 66666 99999 77777455555 44444 22222 11111输出样例2：No one is handsome 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;int ch[100001];int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int flag=1; for(int i=0;i&lt;n;i++) &#123; int k; scanf(\"%d\",&amp;k); for(int i=0;i&lt;k;i++) &#123; int id; scanf(\"%d\",&amp;id); if(k!=1) ch[id]=1; &#125; &#125; int m; scanf(\"%d\",&amp;m); for(int i=0;i&lt;m;i++) &#123; int h; scanf(\"%d\",&amp;h); if(ch[h]==0) &#123; if(flag) &#123; printf(\"%d\",h); ch[h]=1; flag=0; &#125; else &#123; printf(\" %d\",h); ch[h]=1; &#125; &#125; &#125; if(flag) printf(\"No one is handsome\"); printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"question types of ACM","slug":"question-types-of-ACM","permalink":"https://susan514-ywx.github.io/tags/question-types-of-ACM/"}]},{"title":"C++类","slug":"C++之类","date":"2020-02-03T14:44:26.014Z","updated":"2020-02-27T06:50:23.157Z","comments":true,"path":"2020/02/03/C++之类/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/03/C++%E4%B9%8B%E7%B1%BB/","excerpt":"","text":"C++类笔记1.class和struct区别12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class CBase&#x2F;&#x2F;类默认private&#123; int a; int b;&#125;;CBase obji;int x&#x3D;obji.a;&#x2F;&#x2F;错误int t&#x3D;obji.b;&#x2F;&#x2F;错误struct stest&#x2F;&#x2F;结构体默认public&#123; int a; int b;&#125;;stest st;int x&#x3D;st.a;&#x2F;&#x2F;正确int x&#x3D;st.b;&#x2F;&#x2F;正确int main()&#123; return 0;&#125; 1.class不写修饰时，成员默认是private的，而struct默认是public2.class继承默认是private，而struct默认是public的。##2. C++类的定义###2.1格式：###2.2关于public,protected,private的访问权限控制。####2.2.1public的访问权限一个类的public成员变量，成员函数，可以通过类的成员函数，类的实例变量进行访问实例: 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class accessPS&#123;public://可以在类外访问 int pub_num; int pub_Fun()&#123;cout &lt;&lt;\"调用共有成员\"&lt;&lt;endl;return 0;&#125;;private://私有 int pri_num; int pri_Fun()&#123;cout &lt;&lt;\"调用私有成员\"&lt;&lt;endl;return 0;&#125;;protected://保护 int pro_num; int pro_Fun()&#123;cout &lt;&lt;\"调用保护成员\"&lt;&lt;endl;return 0;&#125;;&#125;; int main()&#123; accessPS obja; obja.pub_Fun(); obja.pub_num=1500; cout&lt;&lt;obja.pub_num&lt;&lt;endl; return 0;&#125; 2.2.2protected的访问权限一个类的protected成员变量，成员函数无法通过类的实例变量进行访问，但是可以通过类的友元函数，友元类进行访问。实战技术： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;class accessps&#123;public: friend void pstest(); friend class accesspa;public://可以在类外访问 int pub_num; int pub_Fun()&#123;cout &lt;&lt;\"调用共有成员\"&lt;&lt;endl;return 0;&#125;;private://私有,只能在类内访问 int pri_num; int pri_Fun()&#123;cout &lt;&lt;\"调用私有成员\"&lt;&lt;endl;return 0;&#125;;protected://保护，只能在类内访问 int pro_num; int pro_Fun()&#123;cout &lt;&lt;\"调用保护成员\"&lt;&lt;endl;return 0;&#125;;&#125;;class accesspa&#123; public: void x() &#123; accessps t; t.pro_Fun();//正确的友元类可以访问protected成员函数 int x =t.pro_num;//友元类可以访问protected成员变量 &#125;&#125;;void pstest()&#123; accesspa t; int x=t.x;&#125;int main()&#123; accessps obja; obja.pub_Fun(); obja.pub_num=1500; cout&lt;&lt;obja.pub_num&lt;&lt;endl; return 0;&#125; 2.2.3private访问权限一个类的private成员变量，成员函数，无法通过类的实例变量进行访问，但是可以友元函数，友元类进行访问。实战技术： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;class accesstest&#123; friend void atest(); friend class catest; public: int pub_eme; int pub_fun()&#123;return 0;&#125;; protected: int prot_eme; int pro_fun()&#123;return 0;&#125;; private: int pri_eme; int pri_fun()&#123;return 0;&#125;;&#125;;class catest&#123; public: void x() &#123; accesstest t; t.pri_fun();//友元类可以访问private成员变量函数 int x=t.pri_eme;//友元可以访问private成员变量 &#125;&#125;;void atest()&#123; accesstest t; t.pri_fun(); int x=t.pri_eme;&#125;int main()&#123; accesstest at; // at.pri_mem;//类的外面不能访问私有成员 atest(); return 0;&#125; 总结一句话，public在任何地方都能访问，protected只能在派生类中访问，private只能在友元中进行访问。 3.利用构造函数对类进行初始化3.1对象的初始化在程序中常见对变量赋初值。声明类时对数据成员初始化 12345678910111213141516#include&lt;iostream&gt;using namespace std;class time&#123;public: int hour; int minute; int second;//不能在类声明中对数据成员初始化&#125;;//类不是实体而是抽象类型，不占用空间，显然无法容纳数据time t1=&#123;15,37,98&#125;;int main()&#123; return 0;&#125; 3.2构造函数实现数据成员的初始化问题 C++提供了构造函数（constructor)来处理对象的初始化，是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象的时候自动执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 #include&lt;iostream&gt;using namespace std;class time&#123;public : time()//定义构造成员函数，函数名与类名相同 &#123; hour=0; minute=0; second=0; cout&lt;&lt;\"调用构造函数\"&lt;&lt;endl; &#125; void set_time ();//设置时间 void show_time();//显示时间private: int hour; int minute; int second; &#125;;void time::set_time()&#123; cout&lt;&lt;\"请输入时：分：秒\\n\"; cin&gt;&gt;hour; cin&gt;&gt;minute; cin&gt;&gt;second;&#125;void time::show_time()&#123; cout&lt;&lt;hour&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;second;&#125;int main()&#123; time t1;//创建一个对象调用一次构造函数 t1.show_time(); t1.set_time(); t1.show_time(); time t2;//在哪开始创建在哪开始执行 t2.show_time(); return 0;&#125;","categories":[],"tags":[]},{"title":"easy question types of ACM","slug":"ACM题型","date":"2020-01-27T15:15:28.200Z","updated":"2020-01-31T11:38:34.027Z","comments":true,"path":"2020/01/27/ACM题型/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/27/ACM%E9%A2%98%E5%9E%8B/","excerpt":"","text":"ACM题型 字符判断思路：1). 边输入，边判断2). 全部输入后遍历判断 例题1：TeX中的引号在TeX中，左引号是“”，右引号是“&#39;&#39;”。输入一篇包含双引号的文章，需要把他转换成TeX格式。 样例输入： &quot;To be or not to be,&quot; quoth the Bard, &quot;that is the question&quot;. 样例输出：To be or not to be, quoth the Bard,’’ ``that is the question’’. 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;//char cha[1000];int main()&#123; int f=0,len=0,ok=1; char c; //scanf(\"%s\",cha); //gets(cha); FILE *fp; fp=fopen(\"fin.txt\",\"r\"); if(fp==NULL) &#123; printf(\"error\"); exit(1); &#125; while(!feof(fp)) &#123; c=fgetc(fp); if(c=='\"') &#123; printf(\"%s\",ok?\"``\":\"''\");// ok=!ok; &#125; else printf(\"%c\",c); &#125; fclose(fp); &#125; 例题2：输入一个错位后敲出的字符串，输出本来的句子。输入合法，即一定是错位后的字符串。样例输入：o ;pbr vjoms样例输出:i love china 思路：遍历 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; char alter[]=\"`1234567890-=qwertyuiop[]\\\\asdfghjkl;'zxcvbnm,./\"; char c; int i; /*while((c=getchar())!=EOF) &#123; for(i=1;alter[i];i++) &#123; if(c==alter[i]) break; &#125; if(alter[i]) putchar(alter[i-1]); else putchar(c); &#125; */ while((c=getchar())!=EOF) &#123; for(i=1;alter[i]&amp;&amp;alter[i]!=c;i++);//找错位之后的字符在常量表中的位置 if(alter[i]) putchar(alter[i-1]); else putchar(c); &#125;&#125; 例题3：回文字输入一个字符串，判断他是否文回文串及镜像串,输入的数字不包含0.样例输入：NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA样例输出：NOTAPALINDROME is not a palindrome or a mirrored.ISAPALINILAPASI is a palindrome.2A3MEAS is a mirrored string.ATOYOTA is a mirrored palindrome. 思路：字符数组的遍历 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;ctype.h&gt;const char* rev=\"A 3 HIL JM O 2TUVWXY51SE Z 8 \";//字符型指针，实际是一维字符数组const char* msg[]=&#123;\"not a palindrome or a mirrored\",\"a palindrome\",\"a mirrored string\",\"a mirrored palindrome\"&#125;; //指针数组，实际是二维字符数组char r(char c)&#123; if(isalpha(c)) return rev[c-'A']; return rev[c-'0'+25];&#125;int main()&#123; char s[100]; int i,len; while(scanf(\"%s\",s)!=EOF) &#123; int p=1,m=1; len=strlen(s); for(i=0;i&lt;(len+1)/2;i++)//一半字符 &#123; if(s[i]!=s[len-1-i]) p=0; if(r(s[i])!=s[len-1-i])m=0; &#125; printf(\"%s is %s.\\n\",s,msg[p+m*2]); &#125; return 0; &#125; const它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。 例题3：字符查找实现一个经典的猜数字游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B).样例输入：41 3 5 51 1 2 34 3 3 56 5 5 16 1 3 51 3 5 50 0 0 0101 2 2 2 4 5 6 6 6 91 2 3 4 5 6 7 8 9 11 1 2 2 3 3 4 4 5 51 2 1 3 1 5 1 6 1 91 2 2 5 5 5 6 6 6 70 0 0 0 0 0 0 0 0 00样例输出：Game 1:(1,1)(2,0)(1,2)(4,0)Game 2:(2,4)(3,2)(5,0)(7,0)思路：A可以直接算出，数字1到9各自在答案数组中出现的次数为c1,在猜测数组中出现的次数为c2，min(c1,c2)即给B做的贡献技巧：1.循环语句的灵活运用lin64 2.min如何写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;string.h&gt;# define MAX 101/*int main()&#123; int b[MAX]; int a[MAX]; int t; while(scanf(\"%d\",&amp;t)!=EOF&amp;&amp;t) &#123; int i,f=0; int j=0; for(i=0;i&lt;t;i++) scanf(\"%d\",&amp;a[i]); printf(\"Game %d:\\n\",++f); for( ; ; ) &#123; int A=0,B=0,C=0; for(i=0;i&lt;t;i++) &#123; scanf(\"%d\",&amp;b[i]); if(b[i]==a[i]) A++; &#125; if(b[0]==0) break;//不能打破死循环 for(i=0;i&lt;t;i++)//1 3 5 5 (答案）1 1 2 3 （猜测）题意了解错了 for(j=0;j&lt;t;j++) &#123; if(b[j]==a[i]) C++; &#125; printf(\"(%d,%d)\\n\",A,C-A); &#125; // printf(\"(%d,%d)\\n\",A,A-C); &#125;&#125; */ //我的思路是：借助一个for循环输入一个猜测数组，遇到0是跳出循环（不可实现，因为break只能跳出一层循环）,然后再用一个循环算A // 然后用二层循环算C,则B=C-A； int main()&#123;int n;int a[MAX];int b[MAX];int kase=0;while(scanf(\"%d\",&amp;n)!=EOF&amp;&amp;n)&#123; printf(\"Game %d:\\n\",++kase); int i,j,x; for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); while(1) &#123; int A=0,B=0; for(i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;b[i]); if(a[i]==b[i]) A++; &#125; if(b[0]==0) break; for(j=1;j&lt;=9;j++)//计算数字1到9在答案序列和猜测序列中出现的次数 &#123; int c1=0,c2=0; for(x=0;x&lt;n;x++) &#123; if(j==a[x])c1++;//计算J在答案数列中出现的次数 if(j==b[x])c2++;//计算j在猜测序列中出现的次数 &#125; if(c1&lt;c2) B+=c1; else B+=c2; &#125; printf(\"(%d,%d)\\n\",A,B-A); &#125; &#125; &#125; 例题4：oj平台Sample Input4START1 + 2 = 3ENDSTART1+2=3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 4ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSample OutputPresentation ErrorPresentation ErrorWrong AnswerPresentation Error 思路：ac直接判断即可，pe,wa时，需要取出其数据部分，进行对比技巧：START+数据+END看成整体，即一个字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAX=1000;char a1[MAX],a2[MAX];char b1[MAX],b2[MAX];char tmp[MAX]; void input(char *a,char *b) &#123; gets(tmp); while(gets(tmp)) &#123; if(strcmp(tmp,\"END\")==0)break; strcat(a,tmp); strcat(a,\"\\0\"); &#125; int t=0; int len=strlen(a); for(int i=0;i&lt;len;i++) &#123; if(a[i]!=' '&amp;&amp;a[i]!='\\t'&amp;&amp;a[i]!='\\n') b[t++]=a[i]; &#125; b[t++]='\\0'; &#125;int main()&#123; int i; int n; cin&gt;&gt;n; getchar(); while(n--) &#123; a1[0]='\\0'; a2[0]='\\0'; input(a1,b1); input(a2,b2); if(strcmp(a1,a2)==0) printf(\"Accepted\\n\"); else &#123; if(strcmp(b1,b2)==0) printf(\"Presentation Error\\n\"); else &#123; printf(\"Wrong Answer\\n\"); &#125; &#125; &#125; system(\"pause\");&#125;","categories":[],"tags":[]}]}