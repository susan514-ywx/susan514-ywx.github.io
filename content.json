{"meta":{"title":"Susan","subtitle":"","description":"","author":"Susan","url":"https://susan514-ywx.github.io","root":"/"},"pages":[{"title":"cate","date":"2020-02-04T11:11:38.000Z","updated":"2020-02-04T11:39:24.765Z","comments":true,"path":"categories/index.html","permalink":"https://susan514-ywx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2020-02-04T11:24:34.000Z","updated":"2020-02-04T11:33:39.480Z","comments":true,"path":"tags/index.html","permalink":"https://susan514-ywx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"notes of python","slug":"python","date":"2020-02-15T11:02:29.581Z","updated":"2020-02-15T11:33:58.655Z","comments":true,"path":"2020/02/15/python/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/15/python/","excerpt":"","text":"初学python（有C的基础） 写出习题的代码，在 Linux 下用 gedit，OSX 下用 TextWrangler，Windows 下用 Notepad++。 2. 运行你写的习题。 3. 修改错误的地方。 4. 重复上述步骤。 工具：Notepad++文本编译器 PowerShell##热身 使用terminal创建一个目录&gt;输入mkdir命令创建一个新目录，如mkdir new_dir 创建一个名为new_dir的新目录 使用terminal进入一个目录一直cd简单方法日后更 使用键盘切换回到Terminal窗口win+x 列出文件夹中的内容&gt;dir 语言元素变量和类型 整型：python3.x中可以处理任意大小的整数 浮点型 字符型：由单引号或双引号括起来的任意文本（原始字符串表示法，字节表示法，Unicode表示以后了解） 布尔型：Ture False(首字符大写） 复数型：高中学的复数一样，只做了解变量命名 硬性规则：与C一样 PEP8要求： 1.用小写字母拼写，多个单词用下划线连接2.受保护的实例属性用单个下划线开头3.私有的实例属性用两个下划线开头 变量的使用用实例看变量 #使用type()来检测变量的类型 a=100 b=1.23 c=1+5j d=&#39;hello world&#39; e=True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) python内置函数对变量类型进行转换 int() float() str() chr（） ord() #使用input()函数获取键盘输入（字符串） #使用print（）函数输出带占位符的字符串 a=int(input(&#39;a= &#39;)) b=int(input(&#39;b= &#39;)) print(&#39;%d+%d=%d&#39;%(a,b,a+b)) print(&#39;%d//%d=%d&#39;%(a,b,a//b)) print(&#39;%d%%%d=%d&#39;%(a,b,a%b))//注意 print(&#39;%d**%d=%d&#39;%(a,b,a**b)) 运算符 运算符 解释 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in not or and 逻辑运算符 = += -= = /= %= //= *= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` python格式化字符串 转换说明符 作用 %d、%i 转换为带符号的十进制整数 %o 转换为带符号的八进制整数 %x、%X 转换为带符号的十六进制整数 %e 转化为科学计数法表示的浮点数（e 小写） %E 转化为科学计数法表示的浮点数（E 大写） %f、%F 转化为十进制浮点数 %g 智能选择使用 %f 或 %e 格式 %G 智能选择使用 %F 或 %E 格式 %c 格式化字符及其 ASCII 码 %r 使用 repr() 函数将表达式转换为字符串（什么字符都可输出） %s 使用 str() 函数将表达式转换为字符串 练习：判断是否为闰年 year=int(input(&#39;请输入一个年份：&#39;)) is_leap=(year%4==0 and year%100!=0 or year%400==0) print(is_leap) 附：这也是teacher Lin向我提问的第一个问题，结果我把第1，3个%写成了//，今天又重蹈覆辙。能否被整除要用取余运算符，看余数是否为0，而不是用取整运算符，带个整字，就老想翻你的牌子，因此为界以后涉及于此能想到这两次教训。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://susan514-ywx.github.io/tags/python/"}]},{"title":"C++重载构造函数","slug":"重载构造","date":"2020-02-08T11:44:39.660Z","updated":"2020-02-08T12:31:46.509Z","comments":true,"path":"2020/02/08/重载构造/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/08/%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0/","excerpt":"","text":"给private成员变量赋初值，要通过构造函数（这也是构造函数的作用），不可以在类内直接赋值。 默认构造函数（其实在定义了对象后会自动调用计算机已经写好了的一个默认构造函数，初始值都为0，但作为基本素养，一般会亲自再写一个默认构造函数）（简单点说默认就是指没有实参，初值随意啦） 重载构造函数（此时就是按需自由给private成员变量赋值）#include&lt;iostream&gt; using namespace std; class elevator { public: elevator(); elevator(int floor); void change(); void display(); private: int floor; }; elevator::elevator() { floor=0; printf(&quot;调用该函数1&quot;); } elevator::elevator(int floor1) { floor=floor1; //floor=0;我想调用重载构造函数，但传实参时，结果一直是0，ou~找了好久的错，终于逮住着这个bug了，我直接给变量赋0，传啥也不管用了 printf(&quot;调用该函数2\\n&quot;); } void elevator::change() { char fuhao; cin&gt;&gt;fuhao; if(fuhao==&#39;-&#39;&amp;&amp;floor&gt;=1) floor--; if(fuhao==&#39;+&#39;&amp;&amp;floor&lt;=10) floor++; }void elevator::display(){ cout&lt;&lt;floor;}int main(){ elevator elevator(19); // elevator.change(); elevator.display(); return 0; }```","categories":[],"tags":[{"name":"base of C++","slug":"base-of-C","permalink":"https://susan514-ywx.github.io/tags/base-of-C/"}]},{"title":"桶思想","slug":"acm题型 (2)","date":"2020-02-04T11:17:37.469Z","updated":"2020-02-04T11:39:26.065Z","comments":true,"path":"2020/02/04/acm题型 (2)/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/04/acm%E9%A2%98%E5%9E%8B%20(2)/","excerpt":"","text":"#桶思想的应用 什么是桶思想有种排序为桶排序（还不了解），这种方法耗费了内存空间，但是将时间复杂程度降成了线性，它的特点是先分出一定数目的桶，然后将数字映射到各自的桶中，再对非空桶快速排列。 何时使用该思想？例如：统计一位学生的成绩，可以给试卷分一定数目的桶，学生的成绩即对应桶。 当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。输入格式：输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。输出格式：按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。注意：同一个人可以被查询多次，但只输出一次。输入样例1：33 11111 22222 555552 33333 444444 55555 66666 99999 77777855555 44444 10000 88888 22222 11111 23333 88888输出样例1：10000 88888 23333输入样例2：33 11111 22222 555552 33333 444444 55555 66666 99999 77777455555 44444 22222 11111输出样例2：No one is handsome #include&lt;stdio.h&gt; int ch[100001]; int main() { int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { int flag=1; for(int i=0;i&lt;n;i++) { int k; scanf(&quot;%d&quot;,&amp;k); for(int i=0;i&lt;k;i++) { int id; scanf(&quot;%d&quot;,&amp;id); if(k!=1) ch[id]=1; } } int m; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++) { int h; scanf(&quot;%d&quot;,&amp;h); if(ch[h]==0) { if(flag) { printf(&quot;%d&quot;,h); ch[h]=1; flag=0; } else { printf(&quot; %d&quot;,h); ch[h]=1; } } } if(flag) printf(&quot;No one is handsome&quot;); printf(&quot;\\n&quot;); } }","categories":[],"tags":[{"name":"question types of ACM","slug":"question-types-of-ACM","permalink":"https://susan514-ywx.github.io/tags/question-types-of-ACM/"}]},{"title":"C++类","slug":"C++之类","date":"2020-02-03T14:44:26.014Z","updated":"2020-02-03T14:51:44.988Z","comments":true,"path":"2020/02/03/C++之类/","link":"","permalink":"https://susan514-ywx.github.io/2020/02/03/C++%E4%B9%8B%E7%B1%BB/","excerpt":"","text":"#C++类笔记 1.class和struct区别#include&lt;iostream&gt; using namespace std; class CBase//类默认private { int a; int b; }; CBase obji; int x=obji.a;//错误 int t=obji.b;//错误 struct stest//结构体默认public { int a; int b; }; stest st; int x=st.a;//正确 int x=st.b;//正确 int main() { return 0; } 1.class不写修饰时，成员默认是private的，而struct默认是public2.class继承默认是private，而struct默认是public的。##2. C++类的定义###2.1格式：###2.2关于public,protected,private的访问权限控制。####2.2.1public的访问权限一个类的public成员变量，成员函数，可以通过类的成员函数，类的实例变量进行访问实例: using namespace std; class accessPS { public://可以在类外访问 int pub_num; int pub_Fun(){cout &lt;&lt;&quot;调用共有成员&quot;&lt;&lt;endl;return 0;}; private://私有 int pri_num; int pri_Fun(){cout &lt;&lt;&quot;调用私有成员&quot;&lt;&lt;endl;return 0;}; protected://保护 int pro_num; int pro_Fun(){cout &lt;&lt;&quot;调用保护成员&quot;&lt;&lt;endl;return 0;}; }; #### int main() { accessPS obja; obja.pub_Fun(); obja.pub_num=1500; cout&lt;&lt;obja.pub_num&lt;&lt;endl; return 0; } ####2.2.2protected的访问权限一个类的protected成员变量，成员函数无法通过类的实例变量进行访问，但是可以通过类的友元函数，友元类进行访问。实战技术： #include&lt;iostream&gt; using namespace std; class accessps { public: friend void pstest(); friend class accesspa; public://可以在类外访问 int pub_num; int pub_Fun(){cout &lt;&lt;&quot;调用共有成员&quot;&lt;&lt;endl;return 0;}; private://私有,只能在类内访问 int pri_num; int pri_Fun(){cout &lt;&lt;&quot;调用私有成员&quot;&lt;&lt;endl;return 0;}; protected://保护，只能在类内访问 int pro_num; int pro_Fun(){cout &lt;&lt;&quot;调用保护成员&quot;&lt;&lt;endl;return 0;}; }; class accesspa { public: void x() { accessps t; t.pro_Fun();//正确的友元类可以访问protected成员函数 int x =t.pro_num;//友元类可以访问protected成员变量 } }; void pstest() { accesspa t; int x=t.x; } int main() { accessps obja; obja.pub_Fun(); obja.pub_num=1500; cout&lt;&lt;obja.pub_num&lt;&lt;endl; return 0; }####2.2.3private访问权限一个类的private成员变量，成员函数，无法通过类的实例变量进行访问，但是可以友元函数，友元类进行访问。实战技术： #include&lt;iostream&gt; using namespace std; class accesstest { friend void atest(); friend class catest; public: int pub_eme; int pub_fun(){return 0;}; protected: int prot_eme; int pro_fun(){return 0;}; private: int pri_eme; int pri_fun(){return 0;}; }; class catest { public: void x() { accesstest t; t.pri_fun();//友元类可以访问private成员变量函数 int x=t.pri_eme;//友元可以访问private成员变量 } }; void atest() { accesstest t; t.pri_fun(); int x=t.pri_eme; } int main() { accesstest at; // at.pri_mem;//类的外面不能访问私有成员 atest(); return 0; }总结一句话，public在任何地方都能访问，protected只能在派生类中访问，private只能在友元中进行访问。 ##3.利用构造函数对类进行初始化###3.1对象的初始化在程序中常见对变量赋初值。声明类时对数据成员初始化 #include&lt;iostream&gt; using namespace std; class time { public: int hour; int minute; int second;//不能在类声明中对数据成员初始化 }; //类不是实体而是抽象类型，不占用空间，显然无法容纳数据 time t1={15,37,98}; int main() { return 0; }###3.2构造函数实现数据成员的初始化问题 C++提供了构造函数（constructor)来处理对象的初始化，是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象的时候自动执行。 #include&lt;iostream&gt; using namespace std; class time { public : time()//定义构造成员函数，函数名与类名相同 { hour=0; minute=0; second=0; cout&lt;&lt;&quot;调用构造函数&quot;&lt;&lt;endl; } void set_time ();//设置时间 void show_time();//显示时间 private: int hour; int minute; int second; }; void time::set_time() { cout&lt;&lt;&quot;请输入时：分：秒\\n&quot;; cin&gt;&gt;hour; cin&gt;&gt;minute; cin&gt;&gt;second; } void time::show_time() { cout&lt;&lt;hour&lt;&lt;&quot;:&quot;&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;second; } int main() { time t1;//创建一个对象调用一次构造函数 t1.show_time(); t1.set_time(); t1.show_time(); time t2;//在哪开始创建在哪开始执行 t2.show_time(); return 0; }","categories":[],"tags":[]},{"title":"easy question types of ACM","slug":"ACM题型","date":"2020-01-27T15:15:28.200Z","updated":"2020-01-31T11:38:34.027Z","comments":true,"path":"2020/01/27/ACM题型/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/27/ACM%E9%A2%98%E5%9E%8B/","excerpt":"","text":"ACM题型 字符判断思路：1). 边输入，边判断2). 全部输入后遍历判断 例题1：TeX中的引号在TeX中，左引号是“”，右引号是“&#39;&#39;”。输入一篇包含双引号的文章，需要把他转换成TeX格式。 样例输入： &quot;To be or not to be,&quot; quoth the Bard, &quot;that is the question&quot;. 样例输出：To be or not to be, quoth the Bard,’’ ``that is the question’’. #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; //char cha[1000]; int main() { int f=0,len=0,ok=1; char c; //scanf(&quot;%s&quot;,cha); //gets(cha); FILE *fp; fp=fopen(&quot;fin.txt&quot;,&quot;r&quot;); if(fp==NULL) { printf(&quot;error&quot;); exit(1); } while(!feof(fp)) { c=fgetc(fp); if(c==&#39;&quot;&#39;) { printf(&quot;%s&quot;,ok?&quot;``&quot;:&quot;&#39;&#39;&quot;);// ok=!ok; } else printf(&quot;%c&quot;,c); } fclose(fp); } 例题2：输入一个错位后敲出的字符串，输出本来的句子。输入合法，即一定是错位后的字符串。样例输入：o ;pbr vjoms样例输出:i love china 思路：遍历 #include&lt;stdio.h&gt; int main() { char alter[]=&quot;`1234567890-=qwertyuiop[]\\\\asdfghjkl;&#39;zxcvbnm,./&quot;; char c; int i; /*while((c=getchar())!=EOF) { for(i=1;alter[i];i++) { if(c==alter[i]) break; } if(alter[i]) putchar(alter[i-1]); else putchar(c); } */ while((c=getchar())!=EOF) { for(i=1;alter[i]&amp;&amp;alter[i]!=c;i++);//找错位之后的字符在常量表中的位置 if(alter[i]) putchar(alter[i-1]); else putchar(c); } } 例题3：回文字输入一个字符串，判断他是否文回文串及镜像串,输入的数字不包含0.样例输入：NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA样例输出：NOTAPALINDROME is not a palindrome or a mirrored.ISAPALINILAPASI is a palindrome.2A3MEAS is a mirrored string.ATOYOTA is a mirrored palindrome. 思路：字符数组的遍历 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;ctype.h&gt; const char* rev=&quot;A 3 HIL JM O 2TUVWXY51SE Z 8 &quot;;//字符型指针，实际是一维字符数组 const char* msg[]={&quot;not a palindrome or a mirrored&quot;,&quot;a palindrome&quot;,&quot;a mirrored string&quot;,&quot;a mirrored palindrome&quot;}; //指针数组，实际是二维字符数组 char r(char c) { if(isalpha(c)) return rev[c-&#39;A&#39;]; return rev[c-&#39;0&#39;+25]; } int main() { char s[100]; int i,len; while(scanf(&quot;%s&quot;,s)!=EOF) { int p=1,m=1; len=strlen(s); for(i=0;i&lt;(len+1)/2;i++)//一半字符 { if(s[i]!=s[len-1-i]) p=0; if(r(s[i])!=s[len-1-i])m=0; } printf(&quot;%s is %s.\\n&quot;,s,msg[p+m*2]); } return 0; } const它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。 例题3：字符查找实现一个经典的猜数字游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B).样例输入：41 3 5 51 1 2 34 3 3 56 5 5 16 1 3 51 3 5 50 0 0 0101 2 2 2 4 5 6 6 6 91 2 3 4 5 6 7 8 9 11 1 2 2 3 3 4 4 5 51 2 1 3 1 5 1 6 1 91 2 2 5 5 5 6 6 6 70 0 0 0 0 0 0 0 0 00样例输出：Game 1:(1,1)(2,0)(1,2)(4,0)Game 2:(2,4)(3,2)(5,0)(7,0)思路：A可以直接算出，数字1到9各自在答案数组中出现的次数为c1,在猜测数组中出现的次数为c2，min(c1,c2)即给B做的贡献技巧：1.循环语句的灵活运用lin64 2.min如何写 #include&lt;stdio.h&gt; #include&lt;string.h&gt; # define MAX 101 /*int main() { int b[MAX]; int a[MAX]; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF&amp;&amp;t) { int i,f=0; int j=0; for(i=0;i&lt;t;i++) scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;Game %d:\\n&quot;,++f); for( ; ; ) { int A=0,B=0,C=0; for(i=0;i&lt;t;i++) { scanf(&quot;%d&quot;,&amp;b[i]); if(b[i]==a[i]) A++; } if(b[0]==0) break;//不能打破死循环 for(i=0;i&lt;t;i++)//1 3 5 5 (答案）1 1 2 3 （猜测）题意了解错了 for(j=0;j&lt;t;j++) { if(b[j]==a[i]) C++; } printf(&quot;(%d,%d)\\n&quot;,A,C-A); } // printf(&quot;(%d,%d)\\n&quot;,A,A-C); } } */ //我的思路是：借助一个for循环输入一个猜测数组，遇到0是跳出循环（不可实现，因为break只能跳出一层循环）,然后再用一个循环算A // 然后用二层循环算C,则B=C-A； int main() { int n; int a[MAX]; int b[MAX]; int kase=0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF&amp;&amp;n) { printf(&quot;Game %d:\\n&quot;,++kase); int i,j,x; for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); while(1) { int A=0,B=0; for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;b[i]); if(a[i]==b[i]) A++; } if(b[0]==0) break; for(j=1;j&lt;=9;j++)//计算数字1到9在答案序列和猜测序列中出现的次数 { int c1=0,c2=0; for(x=0;x&lt;n;x++) { if(j==a[x])c1++;//计算J在答案数列中出现的次数 if(j==b[x])c2++;//计算j在猜测序列中出现的次数 } if(c1&lt;c2) B+=c1; else B+=c2; } printf(&quot;(%d,%d)\\n&quot;,A,B-A); } } } 例题4：oj平台Sample Input4START1 + 2 = 3ENDSTART1+2=3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSTART1 + 2 = 4ENDSTART1 + 2 = 3ENDSTART1 + 2 = 3ENDSample OutputPresentation ErrorPresentation ErrorWrong AnswerPresentation Error 思路：ac直接判断即可，pe,wa时，需要取出其数据部分，进行对比技巧：START+数据+END看成整体，即一个字符串 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int MAX=1000; char a1[MAX],a2[MAX]; char b1[MAX],b2[MAX]; char tmp[MAX]; void input(char *a,char *b) { gets(tmp); while(gets(tmp)) { if(strcmp(tmp,&quot;END&quot;)==0)break; strcat(a,tmp); strcat(a,&quot;\\0&quot;); } int t=0; int len=strlen(a); for(int i=0;i&lt;len;i++) { if(a[i]!=&#39; &#39;&amp;&amp;a[i]!=&#39;\\t&#39;&amp;&amp;a[i]!=&#39;\\n&#39;) b[t++]=a[i]; } b[t++]=&#39;\\0&#39;; } int main() { int i; int n; cin&gt;&gt;n; getchar(); while(n--) { a1[0]=&#39;\\0&#39;; a2[0]=&#39;\\0&#39;; input(a1,b1); input(a2,b2); if(strcmp(a1,a2)==0) printf(&quot;Accepted\\n&quot;); else { if(strcmp(b1,b2)==0) printf(&quot;Presentation Error\\n&quot;); else { printf(&quot;Wrong Answer\\n&quot;); } } } system(&quot;pause&quot;); }","categories":[],"tags":[]},{"title":"violent","slug":"bolg4","date":"2020-01-20T03:18:56.296Z","updated":"2020-01-20T03:25:07.683Z","comments":true,"path":"2020/01/20/bolg4/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/20/bolg4/","excerpt":"","text":"灯光照射，圆形探测类问题 题目描述一个nn的网格图上有m个探测器，每个探测器有个探测半径r，问这nn个点中有多少个点能被探测到。输入输出格式输入格式： （1&lt;=r&lt;n&lt;=5000）（1&lt;=m&lt;=5000）第一行3个整数n,m,r接下来m行，每行两个整数x,y表示第i个探测器的坐标输出格式：能被探测到的点的个数 输入输出样例输入样例#1：5 2 13 34 2 输出样例#1：8 三层循环暴力解题法 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; main() { int n,m,r,c=0; int x[101]; int y[101]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r; for(int i=0;i&lt;m;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ for(int k=0;k&lt;m;k++){ double dis=sqrt((x[k]-i)*(x[k]-i)+(y[k]-j)*(y[k]-j)); if(dis&lt;=double (r)) { c++; break; } } } } cout&lt;&lt;c; }","categories":[],"tags":[]},{"title":"HTML","slug":"blog3","date":"2020-01-19T12:40:13.924Z","updated":"2020-01-19T13:04:29.740Z","comments":true,"path":"2020/01/19/blog3/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/19/blog3/","excerpt":"","text":"HTML基础1.HTML标题通过&lt; h1 &gt;-&lt; h6 &gt;等标签进行定义的 。 HTML段落是通过&lt; p &gt;标签进行定义的。 HTML链接通过&lt; a &gt;标签定义。实例:&lt; a href=”http://baidu.com “ &gt; This is a link&lt; /a&gt; href=hypertext reference4.HTML图像通过&lt; img&gt;标签进行定义。实例：&lt; img src=”批注 2020-01-18 161401.jpg” width=”104” height=”142”/&gt; HTML文档是由HTLM元素定义的 HTML元素HTML元素是从开始标签（star tag/opening tag)到结束标签(end tag/closing tag)的所有代码。 嵌套的HTML元素大多数HTML元素可以嵌套HTML文档由嵌套的HTML元素构成。 空的HTML的元素没有内容的HTML元素为空元素。空元素是在开始标签中关闭的。&lt; br&gt;(定义换行）就是没有关闭标签的空元素。但在XHTML,XML,及未来版本中的HTML中，所有元素必须关闭。采用在开始标签中加斜杠/。即:&lt; br/&gt; HTML提示：使用小标签在未来（X)HTML强制使用小写。 HTML属性 属性为HTML元素提供附加信息。 属性实例： HTML链接&lt; a href=”http://baidu.com “ &gt;This is a link&lt; /a&gt; &lt; h1&gt;定义标题的开始&lt; h1 align=”center”&gt;拥有对齐方式的附加信息 &lt; body&gt;d定义HTLM文档的主体&lt; body bycolor=”yellow”&gt;拥有关于背景颜色的附加信息。 &lt; table&gt;定义HTLM表格&lt; table border=”1”&gt;拥有关于表格边框的附加信息。始终为属性值加引号双引号是最常用的，在某些情况下，可使用单引号例如：name=’Bill”hello world”‘HTLM提示： 使用小写属性 属性总是在HTLM元素的开始标签中规定 属性总是以名称——值对的形式出现。HTLM标题 在HTML文档中，标题很重要 HTML标题通过&lt; h1&gt;-&lt; h6&gt;递减定义标题 注释：浏览器会自动地在标题前后添加空格 HTML水平线&lt; hr/&gt;标签在HTLM页面中创建水平线###HTML注释实例：&lt;！–注释内容–&gt; HTML段落HTML折行在不产生新段落的情况下进行换行（新行），使用&lt; br/&gt;,虽然&lt; br&gt;与&lt; br/&gt;很相似，但在XHTLM，XML及未来的HTLM版本中只可使用&lt; br/&gt;。 HTML输出-有用的提示所有连续的空格或空行都会算作一个空格，HTML代码中的所有连续的空行（换行)也被显示为一个空格。 HTML样式 style属性的作用：提供了一种改变HTML元素的通用方法。 实例1.背景颜色&lt; html&gt;&lt; body style=”background-color:yellow”&gt;&lt; h2 style=”background-color:red”&gt;This is a heading&lt; /h2&gt;&lt; p style=”background-color:blue”&gt;This is a paragraph&lt; /p&gt;&lt; /body&gt;&lt; /html&gt;","categories":[],"tags":[]},{"title":"过河卒","slug":"bolg2","date":"2020-01-18T08:19:11.379Z","updated":"2020-01-18T11:28:08.006Z","comments":true,"path":"2020/01/18/bolg2/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/18/bolg2/","excerpt":"","text":"过河卒 动态规划（递推？） 递归 人用迭代，神用递归 棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上的某一点有一个对方的马（如C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点，如图3-1中的C点和P1，……，P8，卒不能通过对方马的控制点。棋盘用坐标表示，A点(0,0)、B点(n, m) (n,m为不超过20的整数),同样马的位置坐标是需要给出的，C≠A且C≠B。现在要求你计算出卒从A点能够到达B点的路径的条数。 【输入】给出n、m和C点的坐标。【输出】从A点能够到达B点的路径的条数。【输入样例】8 6 0 4【输出样例】1617 #include&lt;stdio.h&gt; int main() { int n,m,x,y; //马有9个控制点 int a[9]={0,-2,-2,-1,-1,1,1,2,2};//控制行坐标 int b[9]={0,1,-1,2,-2,2,-2,1,-1};//控制纵坐标 int map[21][21]; long long step[21][21]={0};//step[i][j]表示到(i,J)点的控制数 int i,j; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y); for(i=0;i&lt;21;i++) for(j=0;j&lt;21;j++) map[i][j]=1;//标记地图，1表可走 for(i=0;i&lt;9;i++) if(x+a[i]&gt;=0&amp;&amp;x+a[i]&lt;=n&amp;&amp;y+b[i]&gt;=0&amp;&amp;y+b[i]&lt;=m) map[x+a[i]][y+b[i]]=0;//标记马的控制点，0表不可走 //第一行的控制数 for(i=0;i&lt;21;i++) if(map[0][i]) step[0][i]=1; else break;//遇到马的控制点，停止遍历 //第一列控制数 for(i=0;i&lt;21;i++) if(map[i][0]) step[i][0]=1; else break; //从（1，1）点开始，用递推法，求点（i，j)的控制数 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) step[i][j]=step[i-1][j]*map[i-1][j]+step[i][j-1]*map[i][j-1];//递推公式，如果map为0则该步不可走 printf(&quot;%lld&quot;,step[n][m]); } 全局变量，全局数组默认值为0，局部为随机值 递推与递归的区别相对于递归算法,递推算法免除了数据进出栈的过程，也就是说,不需要函数不断的向边界值靠拢,而直接从边界出发,直到求出函数值 比如阶乘函数：f(n)=nf(n-1)在f(3)的运算过程中,递归的数据流动过程如下:f(3){f(i)=f(i-1)i}–&gt;f(2)–&gt;f(1)–&gt;f(0){f(0)=1}–&gt;f(1)–&gt;f(2)–f(3){f(3)=6}而递推如下:f(0)–&gt;f(1)–&gt;f(2)–&gt;f(3)由此可见,递推的效率要高一些,在可能的情况下应尽量使用递推.但是递归作为比较基础的算法,它的作用不能忽视.所以,在把握这两种算法的时候应该特别注意。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-13T03:53:06.273Z","updated":"2020-01-13T04:12:40.810Z","comments":true,"path":"2020/01/13/hello-world/","link":"","permalink":"https://susan514-ywx.github.io/2020/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}